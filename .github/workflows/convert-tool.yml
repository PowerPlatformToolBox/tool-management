name: Convert and Publish Tool

on:
    workflow_dispatch:
        inputs:
            npm_package_name:
                description: "npm package name"
                required: true
                type: string
            display_name:
                description: "Tool display name"
                required: true
                type: string
            description:
                description: "Tool description"
                required: true
                type: string
            icon_url:
                description: "Icon URL (deprecated - use icon field)"
                required: false
                type: string
            icon:
                description: "Icon path (bundled SVG under dist)"
                required: false
                type: string
            readme_url:
                description: "README URL"
                required: false
                type: string
            version:
                description: "Tool version"
                required: false
                type: string
            license:
                description: "License"
                required: false
                type: string
            csp_exceptions:
                description: "CSP Exceptions"
                required: false
                type: string
            submitted_by:
                description: "Submitted by"
                required: false
                type: string
            features:
                description: "Features"
                required: false
                type: string
            authors:
                description: "Author(s)"
                required: false
                type: string
            repository:
                description: "Repository URL"
                required: false
                type: string
            website:
                description: "Website URL"
                required: false
                type: string

jobs:
    convert:
        runs-on: ubuntu-latest
        permissions: write-all
        env:
            SUPPORTED_ICON_FORMATS: "png|jpg|jpeg|svg"

        steps:
            - name: Checkout repository
              uses: actions/checkout@v4
              with:
                  token: ${{ secrets.GITHUB_TOKEN }}

            - name: Setup Node.js
              uses: actions/setup-node@v4
              with:
                  node-version: "20"

            - name: Extract tool info
              id: tool
              run: |
                  PACKAGE_NAME='${{ inputs.npm_package_name }}'
                  DISPLAY_NAME='${{ inputs.display_name }}'
                  DESCRIPTION='${{ inputs.description }}'
                  AUTHORS='${{ inputs.authors }}'
                  README_URL='${{ inputs.readme_url }}'
                  ICON_URL='${{ inputs.icon_url }}'
                  ICON='${{ inputs.icon }}'
                  REPOSITORY='${{ inputs.repository }}'
                  WEBSITE='${{ inputs.website }}'

                  echo "package=$PACKAGE_NAME" >> $GITHUB_OUTPUT
                  echo "name=$DISPLAY_NAME" >> $GITHUB_OUTPUT
                  echo "description=$DESCRIPTION" >> $GITHUB_OUTPUT
                  echo "authors=$AUTHORS" >> $GITHUB_OUTPUT
                  echo "readme_url=$README_URL" >> $GITHUB_OUTPUT
                  echo "icon_url=$ICON_URL" >> $GITHUB_OUTPUT
                  echo "icon=$ICON" >> $GITHUB_OUTPUT
                  echo "repository=$REPOSITORY" >> $GITHUB_OUTPUT
                  echo "website=$WEBSITE" >> $GITHUB_OUTPUT

            - name: Download and build tool
              id: build
              run: |
                  # Download from npm
                  npm pack ${{ steps.tool.outputs.package }}

                  # Extract
                  tar -xzf *.tgz
                  cd package

                  # Get version from package.json
                  VERSION=$(node -p "require('./package.json').version")
                  echo "version=$VERSION" >> $GITHUB_OUTPUT

                  # Install production dependencies
                  npm install --production --no-optional

                  # Run build if script exists
                  npm run --if-present build || echo "No build script found or build failed"

                  # Create tool ID (kebab-case)
                  TOOL_ID=$(echo "${{ steps.tool.outputs.package }}" | sed 's/@//g' | sed 's/\//-/g')
                  echo "id=$TOOL_ID" >> $GITHUB_OUTPUT

                  cd ..

            - name: Set tool environment
              run: |
                  echo "TOOL_ID=${{ steps.build.outputs.id }}" >> $GITHUB_ENV
                  echo "TOOL_VERSION=${{ steps.build.outputs.version }}" >> $GITHUB_ENV

            - name: Create distribution archive
              run: |
                  cd package

                  # Remove unnecessary files
                  rm -rf .git .github node_modules/*/test node_modules/*/tests
                  rm -rf node_modules/*/*.md node_modules/*/.npmignore
                  find . -name "*.map" -delete
                  find . -name "*.ts" ! -name "*.d.ts" -delete

                  # Create archive
                  tar -czf ../${{ steps.build.outputs.id }}-${{ steps.build.outputs.version }}.tar.gz \
                    --exclude=node_modules/.bin \
                    package.json \
                    dist/

                  cd ..

            - name: Generate checksum
              id: checksum
              run: |
                  CHECKSUM=$(sha256sum ${{ steps.build.outputs.id }}-${{ steps.build.outputs.version }}.tar.gz | awk '{print $1}')
                  SIZE=$(stat -f%z ${{ steps.build.outputs.id }}-${{ steps.build.outputs.version }}.tar.gz 2>/dev/null || stat -c%s ${{ steps.build.outputs.id }}-${{ steps.build.outputs.version }}.tar.gz)

                  echo "checksum=$CHECKSUM" >> $GITHUB_OUTPUT
                  echo "size=$SIZE" >> $GITHUB_OUTPUT

            - name: Extract or download icon
              id: icon
              if: ${{ steps.tool.outputs.icon != '' || steps.tool.outputs.icon_url != '' }}
              run: |
                  ICON="${{ steps.tool.outputs.icon }}"
                  ICON_URL="${{ steps.tool.outputs.icon_url }}"

                  # Prefer bundled icon over external URL
                  if [ -n "$ICON" ]; then
                    echo "Using bundled icon: $ICON"
                    
                    # Check if icon exists in package/dist
                    if [ -f "package/dist/$ICON" ]; then
                      # Extract extension
                      EXTENSION="${ICON##*.}"
                      EXTENSION=$(echo "$EXTENSION" | tr '[:upper:]' '[:lower:]')
                      
                      # Copy icon to release directory
                      ICON_FILENAME="${{ steps.build.outputs.id }}-${{ steps.build.outputs.version }}-icon.${EXTENSION}"
                      cp "package/dist/$ICON" "$ICON_FILENAME"
                      
                      echo "✅ Bundled icon extracted successfully"
                      echo "filename=$ICON_FILENAME" >> $GITHUB_OUTPUT
                      echo "has_icon=true" >> $GITHUB_OUTPUT
                      echo "icon_path=$ICON" >> $GITHUB_OUTPUT
                    else
                      echo "⚠️ Bundled icon not found at package/dist/$ICON"
                      echo "has_icon=false" >> $GITHUB_OUTPUT
                    fi
                  elif [ -n "$ICON_URL" ]; then
                    echo "Using external icon URL (deprecated): $ICON_URL"

                    # Extract file extension from URL
                    EXTENSION="${ICON_URL##*.}"
                    # Remove query parameters if any
                    EXTENSION="${EXTENSION%%\?*}"
                    # Convert to lowercase for validation
                    EXTENSION=$(echo "$EXTENSION" | tr '[:upper:]' '[:lower:]')

                    # Validate extension against supported formats using case statement
                    case "$EXTENSION" in
                      png|jpg|jpeg|svg)
                        echo "✅ Valid icon format: $EXTENSION"
                        ;;
                      *)
                        echo "⚠️ Invalid or unsupported icon format: $EXTENSION"
                        echo "Supported formats: $SUPPORTED_ICON_FORMATS"
                        echo "Defaulting to png"
                        EXTENSION="png"
                        ;;
                    esac

                    # Determine icon filename
                    ICON_FILENAME="${{ steps.build.outputs.id }}-${{ steps.build.outputs.version }}-icon.${EXTENSION}"

                    echo "Downloading icon from: $ICON_URL"
                    if curl -L -f -o "$ICON_FILENAME" "$ICON_URL"; then
                      echo "✅ Icon downloaded successfully"
                      echo "filename=$ICON_FILENAME" >> $GITHUB_OUTPUT
                      echo "has_icon=true" >> $GITHUB_OUTPUT
                    else
                      echo "⚠️ Failed to download icon, continuing without it"
                      echo "has_icon=false" >> $GITHUB_OUTPUT
                    fi
                  fi

            - name: Login to Azure
              uses: azure/login@v2
              with:
                  creds: ${{ secrets.AZURE_CREDENTIALS }}

            - name: Upload tool package and icon to Azure Blob
              run: |
                  set -euo pipefail

                  FOLDER="${TOOL_ID}-${TOOL_VERSION}"

                  az storage blob upload \
                    --account-name ${{ secrets.AZURE_STORAGE_ACCOUNT }} \
                    --container-name ${{ secrets.AZURE_STORAGE_CONTAINER }} \
                    --name "packages/${FOLDER}/${FOLDER}.tar.gz" \
                    --file "${FOLDER}.tar.gz" \
                    --auth-mode login \
                    --overwrite true

                  if [ "${{ steps.icon.outputs.has_icon }}" = "true" ]; then
                    az storage blob upload \
                      --account-name ${{ secrets.AZURE_STORAGE_ACCOUNT }} \
                      --container-name ${{ secrets.AZURE_STORAGE_CONTAINER }} \
                      --name "packages/${FOLDER}/${{ steps.icon.outputs.filename }}" \
                      --file "${{ steps.icon.outputs.filename }}" \
                      --auth-mode login \
                      --overwrite true
                  fi

            # TODO(deprecation): Remove GitHub Release uploads after 2-3 releases once consumers have migrated to Azure Blob.
            - name: Prepare GitHub Release files (deprecated)
              id: release_files
              run: |
                  # Build files list
                  FILES="${TOOL_ID}-${TOOL_VERSION}.tar.gz"
                  if [ "${{ steps.icon.outputs.has_icon }}" = "true" ]; then
                    FILES="${FILES}"$'\n'"${{ steps.icon.outputs.filename }}"
                  fi

                  # Output as multiline string
                  echo "files<<EOF" >> $GITHUB_OUTPUT
                  echo "$FILES" >> $GITHUB_OUTPUT
                  echo "EOF" >> $GITHUB_OUTPUT

            - name: Validate GitHub token can access target repo (deprecated)
              run: |
                  set -euo pipefail

                  # This helps turn opaque 403s into actionable errors (bad credentials, missing perms, SSO not authorized, etc.).
                  STATUS=$(curl -sS -o /tmp/gh_repo_check.json -w "%{http_code}" \
                    -H "Authorization: Bearer ${{ secrets.GH_PAT_TOKEN }}" \
                    -H "Accept: application/vnd.github+json" \
                    https://api.github.com/repos/PowerPlatformToolBox/pptb-web)

                  if [ "$STATUS" != "200" ]; then
                    echo "GitHub API access check failed (HTTP $STATUS) for PowerPlatformToolBox/pptb-web"
                    cat /tmp/gh_repo_check.json
                    exit 1
                  fi

            - name: Upload to GitHub Release (deprecated)
              id: upload_gh_release
              uses: softprops/action-gh-release@v1
              env:
                  # Some actions default to GITHUB_TOKEN env var even when a `token` input is provided.
                  # Force usage of the PAT for cross-repo release creation.
                  GITHUB_TOKEN: ${{ secrets.GH_PAT_TOKEN }}
              with:
                  # Cross-repo release: requires a PAT with access to PowerPlatformToolBox/pptb-web
                  # (GITHUB_TOKEN is scoped to the current repository only).
                  repository: PowerPlatformToolBox/pptb-web
                  token: ${{ secrets.GH_PAT_TOKEN }}
                  tag_name: ${{ steps.build.outputs.id }}-${{ steps.build.outputs.version }}
                  target_commitish: main
                  name: ${{ steps.tool.outputs.name }} v${{ steps.build.outputs.version }}
                  body: |
                      ⚠️ DEPRECATED: GitHub Releases are being phased out in favor of Azure Blob Storage.
                      TODO: Remove this GitHub Release step after 2-3 releases.

                      Tool: ${{ steps.tool.outputs.name }}
                      npm package: ${{ steps.tool.outputs.package }}
                      Version: ${{ steps.build.outputs.version }}
                      Authors: ${{ steps.tool.outputs.authors }}
                  files: ${{ steps.release_files.outputs.files }}

            - name: Build tool metadata JSON
              run: |
                  set -euo pipefail

                  FOLDER="${TOOL_ID}-${TOOL_VERSION}"
                  DOWNLOAD_URL="https://${{ secrets.AZURE_STORAGE_ACCOUNT }}.blob.core.windows.net/${{ secrets.AZURE_STORAGE_CONTAINER }}/packages/${FOLDER}/${FOLDER}.tar.gz"

                  ICON_URL=""
                  if [ "${{ steps.icon.outputs.has_icon }}" = "true" ]; then
                    ICON_URL="https://${{ secrets.AZURE_STORAGE_ACCOUNT }}.blob.core.windows.net/${{ secrets.AZURE_STORAGE_CONTAINER }}/packages/${FOLDER}/${{ steps.icon.outputs.filename }}"
                  fi

                  TOOL_METADATA_JSON=$(jq -c -n \
                    --arg tool_id "${TOOL_ID}" \
                    --arg tool_version "${TOOL_VERSION}" \
                    --arg packageName "${{ steps.tool.outputs.package }}" \
                    --arg name "${{ steps.tool.outputs.name }}" \
                    --arg description "${{ steps.tool.outputs.description }}" \
                    --arg authors "${{ steps.tool.outputs.authors }}" \
                    --arg readme_url "${{ steps.tool.outputs.readme_url }}" \
                    --arg icon "$ICON_URL" \
                    --arg downloadurl "$DOWNLOAD_URL" \
                    --arg checksum "${{ steps.checksum.outputs.checksum }}" \
                    --arg size "${{ steps.checksum.outputs.size }}" \
                    --arg repository "${{ steps.tool.outputs.repository }}" \
                    --arg website "${{ steps.tool.outputs.website }}" \
                    --arg published "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                    '{
                      tool_id: $tool_id,
                      tool_version: $tool_version,
                      packagename: $packageName,
                      name: $name,
                      description: $description,
                      authors: $authors,
                      readmeurl: $readme_url,
                      icon: (if $icon == "" then null else $icon end),
                      downloadurl: $downloadurl,
                      checksum: $checksum,
                      size: ($size | tonumber),
                      repository: (if $repository == "" then null else $repository end),
                      website: (if $website == "" then null else $website end),
                      published_at: $published
                    }')

                  echo "TOOL_METADATA_JSON=$TOOL_METADATA_JSON" >> $GITHUB_ENV

            - name: Regenerate Azure Blob registry.json
              run: |
                  set -euo pipefail

                  az storage blob download \
                    --account-name ${{ secrets.AZURE_STORAGE_ACCOUNT }} \
                    --container-name ${{ secrets.AZURE_STORAGE_CONTAINER }} \
                    --name registry.json \
                    --file registry.json \
                    --auth-mode login \
                    || echo '{"version":"1.0","tools":[]}' > registry.json

                  node buildScripts/updateRegistry.js "${TOOL_ID}" "${TOOL_VERSION}" "$TOOL_METADATA_JSON"

                  az storage blob upload \
                    --account-name ${{ secrets.AZURE_STORAGE_ACCOUNT }} \
                    --container-name ${{ secrets.AZURE_STORAGE_CONTAINER }} \
                    --name registry.json \
                    --file registry.json \
                    --auth-mode login \
                    --overwrite true

            - name: Update Supabase database
              env:
                  SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
                  SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
              if: env.SUPABASE_URL != '' && env.SUPABASE_SERVICE_ROLE_KEY != ''
              run: |
                  FOLDER="${TOOL_ID}-${TOOL_VERSION}"

                  # Prepare icon and download URLs (Azure Blob)
                  ICON_URL=""
                  if [ "${{ steps.icon.outputs.has_icon }}" = "true" ]; then
                    ICON_URL="https://${{ secrets.AZURE_STORAGE_ACCOUNT }}.blob.core.windows.net/${{ secrets.AZURE_STORAGE_CONTAINER }}/packages/${FOLDER}/${{ steps.icon.outputs.filename }}"
                  fi
                  DOWNLOAD_URL="https://${{ secrets.AZURE_STORAGE_ACCOUNT }}.blob.core.windows.net/${{ secrets.AZURE_STORAGE_CONTAINER }}/packages/${FOLDER}/${FOLDER}.tar.gz"

                  # Prepare SQL payload for tools table
                  TOOL_PAYLOAD=$(jq -n \
                    --arg packageName "${{ steps.tool.outputs.package }}" \
                    --arg name "${{ steps.tool.outputs.name }}" \
                    --arg description "${{ steps.tool.outputs.description }}" \
                    --arg icon "$ICON_URL" \
                    --arg version "${{ steps.build.outputs.version }}" \
                    --arg downloadurl "$DOWNLOAD_URL" \
                    --arg checksum "${{ steps.checksum.outputs.checksum }}" \
                    --arg size "${{ steps.checksum.outputs.size }}" \
                    --arg readmeurl "${{ steps.tool.outputs.readme_url }}" \
                    --arg published "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                    --arg license "${{ inputs.license }}" \
                    --arg csp_exceptions "${{ inputs.csp_exceptions }}" \
                    --arg submitted_by "${{ inputs.submitted_by }}" \
                    --arg features "${{ inputs.features }}" \
                    --arg repository "${{ steps.tool.outputs.repository }}" \
                    --arg website "${{ steps.tool.outputs.website }}" \
                    '{
                      packagename: $packageName,
                      name: $name,
                      description: $description,
                      icon: (if $icon == "" then null else $icon end),
                      version: $version,
                      downloadurl: $downloadurl,
                      checksum: $checksum,
                      size: $size,
                      readmeurl: $readmeurl,
                      published_at: $published,
                      license: $license,
                      csp_exceptions: (if $csp_exceptions == "" then null else $csp_exceptions end),
                      user_id: $submitted_by,
                      features: (if $features == "" then null else $features end),
                      repository: (if $repository == "" then null else $repository end),
                      website: (if $website == "" then null else $website end)
                    }')

                  # Insert or update tool metadata in Supabase
                  RESPONSE=$(curl -X POST "${{ secrets.SUPABASE_URL }}/rest/v1/tools" \
                    -H "apikey: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
                    -H "Authorization: Bearer ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
                    -H "Content-Type: application/json" \
                    -H "Prefer: resolution=merge-duplicates,return=representation" \
                    -d "$TOOL_PAYLOAD")

                  echo "Supabase tools response: $RESPONSE"

                  # Extract the tool_id from response
                  TOOL_ID=$(echo "$RESPONSE" | jq -r '.[0].id // empty')

                  if [ -n "$TOOL_ID" ]; then
                    echo "Tool inserted/updated with ID: $TOOL_ID"
                    
                    # Initialize analytics for the tool
                    ANALYTICS_PAYLOAD=$(jq -n \
                      --arg tool_id "$TOOL_ID" \
                      '{
                        tool_id: $tool_id,
                        downloads: 0,
                        rating: 0.0,
                        aum: 0
                      }')

                    curl -X POST "${{ secrets.SUPABASE_URL }}/rest/v1/tool_analytics" \
                      -H "apikey: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
                      -H "Authorization: Bearer ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
                      -H "Content-Type: application/json" \
                      -H "Prefer: resolution=merge-duplicates" \
                      -d "$ANALYTICS_PAYLOAD"
                    
                    echo "Analytics initialized for tool"

                    AUTHOR_LIST="${{ steps.tool.outputs.authors }}"
                    if [ -n "$AUTHOR_LIST" ]; then
                      IFS=',' read -ra AUTHORS <<< "$AUTHOR_LIST"
                      for RAW_AUTHOR in "${AUTHORS[@]}"; do
                        AUTHOR_NAME=$(echo "$RAW_AUTHOR" | xargs)
                        if [ -z "$AUTHOR_NAME" ]; then
                          continue
                        fi

                        # Look up existing contributor by name
                        ENCODED_NAME=$(jq -rn --arg v "$AUTHOR_NAME" '$v|@uri')
                        CONTRIBUTOR_LOOKUP=$(curl -s "${{ secrets.SUPABASE_URL }}/rest/v1/contributors?name=eq.${ENCODED_NAME}&select=id&limit=1" \
                          -H "apikey: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
                          -H "Authorization: Bearer ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
                          -H "Content-Type: application/json")
                        CONTRIBUTOR_ID=$(echo "$CONTRIBUTOR_LOOKUP" | jq -r '.[0].id // empty')

                        if [ -z "$CONTRIBUTOR_ID" ]; then
                          CONTRIBUTOR_PAYLOAD=$(jq -n --arg name "$AUTHOR_NAME" '{name: $name}')
                          CONTRIBUTOR_RESPONSE=$(curl -s -X POST "${{ secrets.SUPABASE_URL }}/rest/v1/contributors?select=id" \
                            -H "apikey: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
                            -H "Authorization: Bearer ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
                            -H "Content-Type: application/json" \
                            -H "Prefer: return=representation" \
                            -d "$CONTRIBUTOR_PAYLOAD")
                          CONTRIBUTOR_ID=$(echo "$CONTRIBUTOR_RESPONSE" | jq -r '.[0].id // empty')
                        fi

                        if [ -n "$CONTRIBUTOR_ID" ]; then
                          TOOL_CONTRIBUTOR_PAYLOAD=$(jq -n \
                            --arg tool_id "$TOOL_ID" \
                            --arg contributor_id "$CONTRIBUTOR_ID" \
                            '{tool_id: $tool_id, contributor_id: ($contributor_id|tonumber)}')

                          curl -s -X POST "${{ secrets.SUPABASE_URL }}/rest/v1/tool_contributors" \
                            -H "apikey: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
                            -H "Authorization: Bearer ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
                            -H "Content-Type: application/json" \
                            -H "Prefer: resolution=ignore-duplicates" \
                            -d "$TOOL_CONTRIBUTOR_PAYLOAD" >/dev/null || true

                          echo "Contributor linked: $AUTHOR_NAME"
                        else
                          echo "Warning: Failed to upsert contributor for author '$AUTHOR_NAME'"
                        fi
                      done
                    fi
                  else
                    echo "Warning: Could not extract tool ID from Supabase response"
                  fi
