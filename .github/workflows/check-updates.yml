name: Check for Tool Updates

on:
    schedule:
        - cron: "0 0 * * *" # Daily at midnight UTC
    workflow_dispatch: # Manual trigger

jobs:
    check-updates:
        runs-on: ubuntu-latest
        permissions:
            contents: write
            pull-requests: write
            actions: write

        steps:
            - name: Checkout repository
              uses: actions/checkout@v4

            - name: Setup Node.js
              uses: actions/setup-node@v4
              with:
                  node-version: "20"

            - name: Check for updates
              id: check
              env:
                  SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
                  SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
              run: |
                  UPDATES_FOUND=false

                  # Fetch tools from Supabase
                  HTTP_CODE=$(curl -s -w "%{http_code}" -o /tmp/tools_response.json "$SUPABASE_URL/rest/v1/tools?select=packagename,version" \
                    -H "apikey: $SUPABASE_SERVICE_ROLE_KEY" \
                    -H "Authorization: Bearer $SUPABASE_SERVICE_ROLE_KEY")
                  TOOLS_RESPONSE=$(cat /tmp/tools_response.json)

                  # Check HTTP status code
                  if [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
                    echo "âŒ Failed to fetch tools from Supabase (HTTP $HTTP_CODE)"
                    echo "Response: $TOOLS_RESPONSE"
                    exit 1
                  fi

                  # Check if response is valid JSON array
                  if ! echo "$TOOLS_RESPONSE" | jq -e 'type == "array"' > /dev/null 2>&1; then
                    echo "âŒ Invalid response from Supabase - expected JSON array"
                    echo "Response: $TOOLS_RESPONSE"
                    exit 1
                  fi

                  # For each tool in Supabase
                  for row in $(echo "$TOOLS_RESPONSE" | jq -r '.[] | @base64'); do
                    _jq() {
                      echo ${row} | base64 --decode | jq -r "${1}"
                    }

                    NPM_PACKAGE=$(_jq '.packagename')
                    CURRENT_VERSION=$(_jq '.version')

                    # Skip if packagename is null or empty
                    if [ -z "$NPM_PACKAGE" ] || [ "$NPM_PACKAGE" = "null" ]; then
                      continue
                    fi

                    # Get latest npm version
                    LATEST_VERSION=$(npm view $NPM_PACKAGE version 2>/dev/null || echo "")

                    if [ -z "$LATEST_VERSION" ]; then
                      echo "âš ï¸ Could not fetch version for $NPM_PACKAGE"
                      continue
                    fi

                    # Compare versions
                    if [ "$LATEST_VERSION" != "$CURRENT_VERSION" ]; then
                      echo "ðŸ”„ Update available for $NPM_PACKAGE: $CURRENT_VERSION â†’ $LATEST_VERSION"
                      echo "$NPM_PACKAGE,$CURRENT_VERSION,$LATEST_VERSION" >> updates.txt
                      UPDATES_FOUND=true
                    fi
                  done

                  echo "found=$UPDATES_FOUND" >> $GITHUB_OUTPUT

            - name: Create tool_updates record in Supabase
              if: steps.check.outputs.found == 'true'
              env:
                  SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
                  SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
              run: |
                  # Remove any stale mapping file so this run controls what gets processed
                  rm -f tool_update_ids.txt
                  while IFS=',' read -r PACKAGE CURRENT_VERSION LATEST_VERSION; do
                    if [ -z "$PACKAGE" ]; then
                      continue
                    fi
                    if [ -z "$LATEST_VERSION" ]; then
                      continue
                    fi

                    PACKAGE_FILTER=$(printf '%s' "$PACKAGE" | jq -sRr @uri)
                    VERSION_FILTER=$(printf '%s' "$LATEST_VERSION" | jq -sRr @uri)

                    EXISTING_RESPONSE=$(curl -sS "$SUPABASE_URL/rest/v1/tool_updates?select=id&package_name=eq.$PACKAGE_FILTER&version=eq.$VERSION_FILTER&limit=1" \
                      -H "apikey: $SUPABASE_SERVICE_ROLE_KEY" \
                      -H "Authorization: Bearer $SUPABASE_SERVICE_ROLE_KEY")

                    if echo "$EXISTING_RESPONSE" | jq -e 'type == "array" and length > 0' > /dev/null 2>&1; then
                      EXISTING_ID=$(echo "$EXISTING_RESPONSE" | jq -r '.[0].id // empty')
                      if [ -n "$EXISTING_ID" ]; then
                        echo "tool_updates already exists for $PACKAGE@$LATEST_VERSION (id=$EXISTING_ID); enqueueing for processing."
                        echo "$PACKAGE,$EXISTING_ID" >> tool_update_ids.txt
                      else
                        echo "Warning: tool_updates exists for $PACKAGE@$LATEST_VERSION but no id was returned; skipping enqueue."
                      fi
                      continue
                    fi

                    RESPONSE=$(curl -sS -X POST "${{ secrets.SUPABASE_URL }}/rest/v1/tool_updates" \
                      -H "apikey: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
                      -H "Authorization: Bearer ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
                      -H "Content-Type: application/json" \
                      -H "Prefer: resolution=merge-duplicates,return=representation" \
                      -d "{\"package_name\":\"$PACKAGE\",\"version\":\"$LATEST_VERSION\"}")

                    echo "Supabase tools response for $PACKAGE: $RESPONSE"

                    # Check if response is an error object
                    if echo "$RESPONSE" | jq -e '.code' > /dev/null 2>&1; then
                      echo "âŒ Error creating tool_updates record for $PACKAGE: $RESPONSE"
                      continue
                    fi

                    # Extract the inserted id (Supabase returns an array when using return=representation)
                    TOOL_UPDATES_ID=$(echo "$RESPONSE" | jq -r 'if type == "array" then .[0].id else .id end // empty')

                    # Persist mapping for the next step
                    if [ -n "$TOOL_UPDATES_ID" ]; then
                      echo "$PACKAGE,$TOOL_UPDATES_ID" >> tool_update_ids.txt
                    else
                      echo "Warning: No tool_updates id returned for $PACKAGE"
                    fi
                  done < updates.txt

            - name: Invoke NextJS Update Tool API
              if: steps.check.outputs.found == 'true'
              env:
                  UPDATE_TOOL_API_URL: ${{ secrets.UPDATE_TOOL_API_URL }}
              run: |
                  set -euo pipefail
                  if [ -z "$UPDATE_TOOL_API_URL" ]; then
                    echo "âŒ Secret UPDATE_TOOL_API_URL is not set."
                    exit 1
                  fi
                  # Iterate over created tool_update ids and notify API per package
                  if [ ! -f tool_update_ids.txt ]; then
                    echo "No tool_update_ids.txt found; skipping API notifications."
                    exit 0
                  fi
                  while IFS=',' read -r PACKAGE TOOL_UPDATES_ID; do
                    if [ -z "$PACKAGE" ] || [ -z "$TOOL_UPDATES_ID" ]; then
                      continue
                    fi
                    PAYLOAD=$(jq -c -n --arg packageName "$PACKAGE" --arg toolUpdateId "$TOOL_UPDATES_ID" '{packageName: $packageName, toolUpdateId: $toolUpdateId}')

                    echo "Notifying update API for $PACKAGE (tool_update_id=$TOOL_UPDATES_ID)"

                    HEADERS_FILE=$(mktemp)
                    BODY_FILE=$(mktemp)

                    HTTP_CODE=$(curl -sS -L --post301 --post302 --post303 -X POST "$UPDATE_TOOL_API_URL" \
                      -H "Content-Type: application/json" \
                      -d "$PAYLOAD" \
                      -D "$HEADERS_FILE" \
                      -o "$BODY_FILE" \
                      -w "%{http_code}")

                    if [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
                      echo "âŒ Update API call failed for $PACKAGE (HTTP $HTTP_CODE)"
                      echo "--- Response headers ---"
                      cat "$HEADERS_FILE" || true
                      echo "--- Response body (first 2000 bytes) ---"
                      head -c 2000 "$BODY_FILE" || true
                      echo
                      rm -f "$HEADERS_FILE" "$BODY_FILE"
                      exit 1
                    fi

                    LOCATION=$(grep -i '^location:' "$HEADERS_FILE" | tail -n 1 | sed -E 's/^location:[[:space:]]*//I' || true)
                    if [ -n "$LOCATION" ]; then
                      echo "â„¹ï¸ Followed redirect to: $LOCATION"
                    fi

                    rm -f "$HEADERS_FILE" "$BODY_FILE"
                  done < tool_update_ids.txt
